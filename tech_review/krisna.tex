

% ================================================================================================================================

\subsection{User Interface Toolkit}
\subsubsection{Context}
Graphical user interface will be a crucial of for our project presentation and demonstration system.
The algorithm from our project will output a raw alignment data and it will be hard to understand the output without the help of graphical user interface.
The graphical user interface will put contexts to the data and presents the correct symbology of the alignment data output.
User interface toolkits is needed to develop our project user interface.
We are looking for a user interface toolkit that will not add more complexity to the project, have minimal impact on the development process of the project, and have a useful library for user interface functionality. \\

\subsubsection{Options}
There are three options for the user interface toolkit.
The first option is the visual studio user interface toolkit.
Visual studio user interface toolkit is a built-in toolkit in visual studio that used for programmer to create a window application user interface.
The second option is GTK+ toolkit.
GTK+ toolkit is an open source cross-platform widget toolkit for creating graphical user interfaces \cite{gtk}.
The last option is the IUP portable user interface.
IUP is a computer software development kit that provides a portable, scriptable toolkit to build a graphical user interface \cite{iup}. \\


\subsubsection{Criteria}
\begin{enumerate}
	\item \textbf{Complexity}: Our clients encouraged us to spend most our time in developing and refining the dynamic alignment algorithm. Having a less complex toolkit will give us extra time to work on the alignment algorithm. 
	\item \textbf{Accessibility}: Toolkit and library that is easily accessible is desired in this project. A free and easy to access toolkit is desired. 
	\item \textbf{Adoption Rate}: Toolkit that well adapted in the programmer community will have more resources for debugging and refining our user interface. 
	\item \textbf{Time Commitment}: Using a user interface toolkit that will require huge learning curve and time to learn it will not add much benefits to the overall project. 
	\item \textbf{Library}: More powerful library will have more tool to further refine our graphical user interface. 
	\item \textbf{Overall cost and benefits}: Key strengths and weaknesses of using a particular user interface toolkit.\\
\end{enumerate}

\newpage
\subsubsection{Table of Detailed Comparison}
\hfill \break
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Toolkit Name}             & \textbf{Visual Studio Toolkit}                                                                                                           & \textbf{GTK+}                                                                                         & \textbf{IUP}                                                                                                                               \\ \hline
\textbf{Complexity}               & Least complex                                                                                                                            & Less complex                                                                                          & Most complex                                                                                                                               \\ \hline
\textbf{Accessibility}            & \begin{tabular}[c]{@{}c@{}}Accessible for free. Already \\ have it in our computer.\end{tabular}                                         & Accessible for free online.                                                                           & Accessible for free online.                                                                                                                \\ \hline
\textbf{Adoption Rate}            & \begin{tabular}[c]{@{}c@{}}Have a lot of\\ tutorials and references online\end{tabular}                                                  & \begin{tabular}[c]{@{}c@{}}The most popular toolkit for \\ graphical user interface.\end{tabular}     & \begin{tabular}[c]{@{}c@{}}Less popular\\   than GTK+ toolkit.\end{tabular}                                                                \\ \hline
\textbf{Time Commitment}          & Minimal                                                                                                                                  & Medium                                                                                                & High                                                                                                                                       \\ \hline
\textbf{Library}                  & Least powerful                                                                                                                           & Less powerful                                                                                         & Most powerful                                                                                                                              \\ \hline
\textbf{Overall Cost and Benefit} & \begin{tabular}[c]{@{}c@{}}Simple and easy to use \\ toolkit. The least powerful \\ toolkit, with \\ the least learning curve.\end{tabular} & \begin{tabular}[c]{@{}c@{}}More powerful option \\ than visual studio, \\ simpler than IUP.\end{tabular} & \begin{tabular}[c]{@{}c@{}}The most powerful option. \\ A complete \\ development tool. Have the \\ most cost and learning curve\end{tabular} \\ \hline
\end{tabular}
\end{center}


\hfill \break
\subsubsection{Overall Discussion}
By comparing criteria visual studio toolkit is the simplest and ready to use user interface toolkit option.
All of the user interface toolkit options are easily accessible and available for free online.
Although, IUP is the most powerful option that we have, it will also bring a lot of complexity to our project.
IUP is a development tool that completely different than visual studio, using IUP will change the workflow of the development process.
The learning curve and time commitment to learn IUP is huge and it will reduce our time to work on the algorithm of the project.
Although GTK+ has the best overall cost and benefits, there is learning curve associated with it and it will also reduce our time to work on the algorithm of the project.
Although a user interface is a critical part in our project presentation, this functionality is not a critical part of the project as a whole.
Our clients strongly emphasize the quality of our algorithm.
The most important piece of this project is the dynamic alignment algorithm and our clients encouraged us to spend most our time in developing and refining the dynamic alignment algorithm.
Thus, using the toolkit with the least learning curve is encouraged for our project.
This makes us decided to use the built-in visual studio toolkit to create our projectâ€™s graphical user interface. 


% ================================================================================================================================

\subsection{Programming Language}
\subsubsection{Context}
We are looking for a better programming language that will help us to improve the quality of our project in terms of complexity, speed, and memory allocation.
The goal of using a particular programming language is to reduce the complexity of writing code for our project, while having an acceptable speed and spaces memory.
Programming language that has compatibility with the hardware is also desired.\\

\subsubsection{Options}
Our clients give us freedom to choose the programming language that we want to use to create this project.
There are three options for programming language that we can use for this project.
The options for the programming languages are C, C++, and Assembly language.\\

\subsubsection{Criteria}
\begin{enumerate}
	\item \textbf{Language Orientation}: Language orientation will change the way we implement the algorithm. More familiar language orientation is desired. 
	\item \textbf{Language Level}: Low-level programming language is a programming language that provides little or no abstraction from a computer's instruction set architecture \cite{low}. 
	\item \textbf{Complexity}: This criteria will determine the difficulty and complexity of implementing algorithms in a particular programming language. Less complex programming language is desired.
	\item \textbf{Speed}: This criteria will determine the running speed of a compiled software written in a particular programming language. A fast running software is desired for this project. 
	\item \textbf{Memory Allocation}: This criteria will determine the memory allocation required to store a compiled software written in a particular programing language. This criteria will also determine the memory usage of a software during running time. More efficient memory allocation is desired for this project. 
	\item \textbf{Hardware Compatibility}: This criteria will determine the communication efficiency between the software and the hardware. More compatible programming language is desired for this project. 
	\item \textbf{Overall Cost and Benefit}: Key strengths and weaknesses of writing software in a particular programming language.\\
\end{enumerate}

\subsubsection{Table of Detailed Comparison}
\hfill \break
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Language Name}                                  & \textbf{C}                                                                                                                            & \textbf{C++}                                                                                                    & \textbf{Assembly}                                                                                                                                                     \\ \hline
\textbf{Language Orientation}                           & Object oriented                                                                                                                       & Object oriented                                                                                                 & No orientation                                                                                                                                                        \\ \hline
\textbf{Language Level}                                 & High level language                                                                                                                   & High level Language                                                                                             & Low level language                                                                                                                                                    \\ \hline
\textbf{Complexity}                                     & Medium                                                                                                                                & Medium                                                                                                          & Complex                                                                                                                                                               \\ \hline
\textbf{Speed}                                          & Fast                                                                                                                                  & Fast                                                                                                            & Fastest                                                                                                                                                               \\ \hline
\textbf{Memory Allocation}                              & More efficient                                                                                                                        & Most efficient                                                                                                  & Most efficient                                                                                                                                                        \\ \hline
\textbf{Hardware Compatibility}                         & More Compatible                                                                                                                       & Compatible                                                                                                      & Most Compatible                                                                                                                                                       \\ \hline
\multicolumn{1}{|l|}{\textbf{Overall Cost and Benefit}} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}The best high level \\ programming language \\ to interact with hardware\end{tabular}} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}The less hardware \\ compatibility version \\ of C\end{tabular}} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}The most complex \\ programming language \\ with the best performance \\ to communicate with \\ hardware\end{tabular}} \\ \hline
\end{tabular}
\end{center}

\hfill \break
\subsubsection{Overall Discussion}
Based from the criteria above, it is clear that assembly language has the best performance and benefits in writing a program that works with hardware.
However, the low level language of assembly makes writing code in assembly really complex.
With little or no abstraction from a computer's instruction set architecture, this will slow our development time for the algorithm of this project.
C++ is a great programming language that is adopted greatly in the programmer community.
However, in terms of our project requirement, it is also clear that C++ is the less hardware compatibility version of C.
C is arguably one of the best high level programming language to interact with hardware.
This makes us decide to use C as our programming language for this project.  



% ================================================================================================================================

\subsection{Statistical Analysis Method}
\subsubsection{Context}
The goal of using a statistical analysis method is to find the credibility of the output that we get from the algorithm.
There are a lot of options of using statistical method to further refine our alignment data.
We are looking for a statistical analysis method that will allow us to find the credibility on our alignment data or error tolerance. \\

\subsubsection{Options}
Confidence interval, credible interval, and tolerance interval are three possible options of statistical analysis method that we can use to gain credibility of our alignment data.
Confidence interval will measure the frequency of repeated events \cite{stat}.
How much true value that we get from running the test repeatedly.
Credible interval will give us the degree of certainty about a values, given the observed data, there is a probability that the true value of falls within the credible region \cite{stat}.
Tolerance interval will give us the spread of error in our alignment data.\\

\subsubsection{Criteria}
\begin{enumerate}
	\item \textbf{Type of statistics}: Each statistics have their own philosophy of finding credibility of their data. We will determine which type of statistics is most suitable for the project. 
	\item \textbf{Parameters}: In our project case, the parameter will be the expected value of alignment data. 
	\item \textbf{Data}: The data will be the alignment data outputs that we get from the algorithm.  
	\item \textbf{Bound}: We are looking to achieve error within an acceptable bound for confidence and credible interval. Tolerance interval will give us bound values of the sample after the calculation. 
	\item \textbf{Result}: The result will vary for each method. We will determine which result will be the most appropriate.\\
\end{enumerate}

\subsubsection{Table of Detailed Comparison}
\hfill \break
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Method Name}        & \textbf{Confidence Interval}                                              & \textbf{Credible Interval}                                                     & \textbf{Tolerance Interval}                                                           \\ \hline
\textbf{Type of Statistics} & Frequentist                                                               & Bayesian                                                                       & Can be both                                                                           \\ \hline
\textbf{Parameters}         & Fix                                                                       & Random                                                                         & Fix                                                                                   \\ \hline
\textbf{Data}               & Random                                                                    & Random                                                                         & Fix                                                                                   \\ \hline
\textbf{Bound}              & Fix                                                                       & Fix                                                                            & Random                                                                                \\ \hline
\textbf{Result}             & \begin{tabular}[c]{@{}c@{}}Frequency of true\\  value output\end{tabular} & \begin{tabular}[c]{@{}c@{}}Degree of uncertainty \\ about a value\end{tabular} & \begin{tabular}[c]{@{}c@{}}Statistics of\\ acceptable \\ error tolerance\end{tabular} \\ \hline
\end{tabular}
\end{center}

\hfill \break
\subsubsection{Overall Discussion}
The confidence interval will give us the frequency of the true value output being generated by the algorithm over a time period.
While being run repeatedly, our algorithm will produce the same result, which implies the consistency and the credibility of our algorithm data.
However, until the time of calculation, we are not sure what kind of value that we will get from the algorithm.
Hence, leaving us with no parameter to work on confidence interval.
The tolerance interval will give us the spread of error in alignment data being generated by the algorithm.
Tolerance interval can be a great way for us to make sure that we have fulfil the error tolerance requirement for this project.
This statistical method can also be useful for us to further refine our algorithm.
We can adjust the alignment data by the error interval that tolerance interval gave us to make our alignment data more accurate.
Credible interval will give us the credibility to state the certainty of a true value within an interval of data.
This method will give us the true value that might be a great representation of our alignment data.
We think that credible interval method fits the most with our project.
Thus, this makes us decide to do credible interval for our statistical analysis method. 


















