\newpage
\section{Change since Original Requirement Document}
\hfill \break
\begin{center}
\begin{tabular}{|c|p{5cm}|c|p{5cm}|}
\hline
\textbf{} & \textbf{Requirement} & \textbf{What happened to it?} & \textbf{Comments} \\ \hline
\textbf{1}
& Our user interface will be the physical manipulation of our demonstration system in order to generate movement data.
& Completed.
& We built an object that can be moved as well as manipulated to change the pitch and roll.
\\ \hline
 
\textbf{2}
& The software user interface for this project is a display that will show the properly aligned symbology of the airplane.
& Completed.
& Our display shows the static offset values along with the current positions of both aircraft and HUD sensors via a dynamic GUI using aircraft models.
\\ \hline
 
\textbf{3}
& We will use a generic HUD symbology picture which could be moved up/down, left/right which will be used to illustrate the alignment.
& Changed.
& We created a generic HUD symbology but ended up using aircraft models instead.
\\ \hline
 
\textbf{4}
& A microcontroller will have access to data from two separate 9-axis sensors that are used to represent the aircraft IRU and HUD mounted MEMS IRU.
& Completed.
& The microcontroller is connected to both IMUs via I2C as well as using digital logic pins connected to the IMUs respective AD0 pins.
\\ \hline
 
\textbf{5}
& The microcontroller will additionally be connected to an output device which will be used to display the results.
& Completed.
& The microcontroller can be connected to a laptop via serial communication.
\\ \hline
 
\textbf{6}
& The microcontroller hardware has yet to be chosen.
& Changed.
& We choose to use the Metro Mini 328.
\\ \hline
 
\textbf{7}
& The MEMS hardware has yet to be chosen.
& Changed.
& We choose to use the MPU-9250.
\\ \hline
 
\textbf{8}
& We will use C-like language (C/C++) to program this project on Arduino IDE.
& Completed.
& Our solution was written in the selected language and developed through the Arduino IDE.
\\ \hline
 
\textbf{9}
& We will also use the ATmega328P library since we will use the ATmega328P chip as our microcontroller board
& Completed.
& Our solution uses the ATmega328P library.
\\ \hline
 
\textbf{10}
& Additional library/software that we may use has yet to be specified.
& Changed.
& We used VPython, pySerial along with an open source library for the MPU-9250.
\\ \hline
 
\textbf{11}
& I2C protocol will be used to communicate between microcontroller and IMUs.
& Completed.
& We used the I2C protocol to communicate between microcontroller and IMUs.
\\ \hline
 
\textbf{12}
& This program will have the capability to recognize sensors.
& Completed.
& Using I2C, we can recognize and communicate with available sensors.
\\ \hline
 
\textbf{13}
& This program shall recognize and identify all sensors provided to the system.
& Completed.
& We can recognize and identify all sensors after modifying the magnetometer to act as a slave to its respective IMU.
\\ \hline
 
\textbf{14}
& This program will correctly interpret the data provided by the recognized sensors.
& Completed.
& We are able to retrieve the x, y, and z data from the accelerometer, gyroscope, and magnetometer.
\\ \hline
 
\end{tabular}
\end{center}
 
\hfill \break

\hfill \break
\begin{center}
\begin{tabular}{|c|p{5cm}|c|p{5cm}|}
\hline
\textbf{} & \textbf{Requirement} & \textbf{What happened to it?} & \textbf{Comments} \\ \hline

\textbf{15}
& This program will have the ability to do quaternion manipulation on the inputs.
& Completed.
& We the magdwick filter to convert our sensor data into quaternions. We can take the difference between two quaternions.
\\ \hline

\textbf{16}
& Inputs that are received from the sensors will be compared and manipulated to determine the alignment error.
& Completed.
& We can take the difference between two sets of values to find the alignment offset.
\\ \hline
 
\textbf{17}
& Alignment error is found within one milliradian.
& Pending.
& We have yet to test our algorithmic results against the physical offset.
\\ \hline
 
\textbf{18}
& An alignment error reading will be found within 500 milliseconds of starting its function.
& Completed.
& Not counting initialization, the readings are returned under 500 milliseconds.
\\ \hline
 
\textbf{19}
& This program will have the capability to generate a confidence interval for the alignment error output being generated by the algorithm.
& Completed.
& We calculate the confidence interval for 95.
\\ \hline
 
\textbf{20}
& Outputs in the form of alignment error will be used to determine the confidence interval of the data.
& Completed.
& We take a set of alignment offset samples to determine the confidence interval.
\\ \hline
 
\textbf{21}
& The confidence interval will be found in 500 milliseconds of starting its function.
& Completed.
& We take 80 samples before determining the confidence interval.
\\ \hline
 
\textbf{22}
& This program will have the capability to display the properly aligned symbology fo the airplane by using either external LCD display or graphic software (etc., OpenGL).
& Completed.
& We use VPython to display our results.
\\ \hline
 
\textbf{23}
& A generic HUD symbology picture could be moved up/down, left/right and will be used to illustrate the alignment of the airplane.
& Changed.
& We created a generic HUD symbology but ended up using aircraft models instead.
\\ \hline
 
\textbf{24}
& Two terminals will be supported; one for each MEMS sensor.
& Completed.
& We can access each IMU.
\\ \hline
 
\textbf{25}
& We will handle a programmable 3.9 to 8000 data per seconds of information.
& Completed.
& The rate at which samples are taken can be changed and our device supports our requirements.
\\ \hline
 
\textbf{26}
& We will start with 10 data per seconds from both sensors.
& Completed.
& We started with few readings and increased as our devices allowed.
\\ \hline
 
\textbf{27}
& We will handle quaternion information.
& Completed.
& We convert our sensor values into quaternions and manipulate or display the quaternion values.
\\ \hline
 
\textbf{28}
& The valid range of accuracy is milliradians
& Completed.
& We used milliradians for data output.
\\ \hline
 
\textbf{29}
& The destination of output will be the simulated HUD interface.
& Changed.
& We created a generic HUD symbology but ended up using aircraft models instead.
\\ \hline
 
\end{tabular}
\end{center}
 
\hfill \break